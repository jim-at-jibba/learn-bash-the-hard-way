=== Tests

Tests are a fundamental part of bash scripting, whether it's on the command line in one-liners or much larger scripts.

The subject is very fiddly and confusing. In this section I'll show you some pitfalls, and give rules of thumb for practical bash usage.


==== 

Tests are constructs that allow you to do conditional expressions in bash. They use the square brackets to enclose what is being tested.

The simplest test might be:

----
TODO$ [ /bin/false ]
TODO$ echo $?
----

but this is little different from just running /bin/false.

Things get more interest




----
TODO$ A=1
TODO$ [ $A = 1 ]
TODO$ echo $?
TODO$ [ $A == 1 ]
TODO$ echo $?
TODO$ [ $A = 2 ]
TODO$ echo $?
----

Single assignment works TODO

It is worth noting that '[' is in fact a builtin, as well as (very often) a program.

----
TODO$ which [
TODO$ builtin [
----

... and that '[' and 'test' are synonymous

----
TODO$ which test
TODO$ builtin test
----

NOTE: which is a program (not a builtin!) that tells you where a program can be
found.

This is why a space is required after the '[', because it's a separate command and spacing is how bash determines where one command ends and another begins.

==== Logic operators

What do you expect the output of this to be?

----
TODO$ ( [ 1 = 1 ] || [ ! '0' = '0' ] ) && [ '2' = '2' ]
TODO$ echo $?
----

Similar to other languages, '!' means 'not', '||' means 'or', '&&' means 'and' and items within '()' are evaluated first.

Note that to combine the 

If you want to do everything 

----
TODO$ [  1 = 1 -o  ! '0' = '0'  -a  '2' = '2' ]
TODO$ echo $?
----

You can use '-o' as an 'or' operator within the square brackets, but you can't use '(' grouping within them.

If you're not confused yet, you might be soon!

==== [[

There is another very similar operator to the 'test' one that has two angle brackets:

----
TODO$ [[ 1 = 1 ]]
TODO$ echo $?
----

This confused me a lot for some time!

The differences between '[[' and '[' are relatively subtle. Type these lines to see examples: TODO

----
TODO$ [ ${DOESNOTEXIST} = '' ]
TODO$ echo $?
TODO$ [[ ${DOESNOTEXIST} = '' ]]
TODO$ echo $?
TODO$ [ x${DOESNOTEXIST} = 'x' ]
TODO$ echo $?
----


You frequently come across code like this:

----
TODO$ [ "x$DOESNOTEXIST" = "x" ]
----

This is to handle those edge cases when using '[', but it is a bit confused. You don't actually need the 'x' because the quotes take care of it, but the rules are so complicated people write it as a superstition.

Once again, understanding how quotes work is critical to bash mastery!

NOTE: If you want to understand more, follow [this link](http://serverfault.com/questions/52034/what-is-the-difference-between-double-and-single-square-brackets-in-bash)

Oh, and '[[' doesn't like the '-a' (and) and '-o' (or) operators.


==== Confused?

You're not alone. In practice, I follow most style guides and always use '[[' until there is a good reason not to.

If I come across some tricky logic in code I need to understand, I just look it up then.

==== -a etc

TODO

==== Types

NUMBERS vs STRINGS

==== if


==== What You Learned

1) TODO

==== Exercises

1) TODO
