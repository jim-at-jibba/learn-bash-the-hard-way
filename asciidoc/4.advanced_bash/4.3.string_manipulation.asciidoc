== String Manipulation

Since so much of working in bash is related to files and strings of text, the
ability to manipulate strings is valuable.

While tools such as sed, awk, perl (and many many others) are well worth
learning, in this section I want to show you what is possible in bash - and it
may be more than you think!


=== String Length

One of the most common requirements when working with strings is to determine
length:

----
$ mkdir lbthw_strings
$ cd lbthw_strings
$ A='12345678901234567890'
$ echo "${#A}"
$ echo "$#A"
----


Why did the second one not 'work'?



=== String Editing

Bash provides a way to extract a substring from a string. The following example
expains how to parse n characters starting from a particular position.

Work out what's going on here. You may need to consult the manual:

----
$ echo ${A:2}
$ echo ${A:2:3}
----

You can replace sections of scripts using search and replace. The first part
enclosed in '/' signs represents what's searched for, and the second what is
replaced:

----
$ echo "${A/234/432}"
$ echo "${A//234/432}"
----



What's going on in the second command above? How does it differ from the first?


=== Extglobs and removing text

A more advanced means of working with strings is possible by using bash's
extglobs functionality.

A word of warning here: although this functionality is useful to know, it is
arguably less useful than learning the programs 'sed' and 'perl' for this
purpose. It's also quite confusing to have this extra type of glob syntax to
learn in addition to regular expressions (and there's even flavours of those
too!).


----
$ set -o extglob
$ B="  ${A}  "
$ echo "|${B}|"
----

You've ensured that the 'extglob' option is on, and created a new variable 'B',
which is 'A' with two spaces in front and behind. The pipe ('|') character is
used in the echo output to show where the spaces are.

----
$ echo "|{B# }|"
$ echo "|${B#?( )}|"
$ echo "|${B#+( )}|"
$ echo "|${B#*( )}|"
$ echo "|${B##+( )}|"
----

Using the bash man page, and experimenting, can you figure out the differences
between the above extglobs? The are:

- ?( )
- +( )
- *( )


//Trim?
//Replace beginning and end
//C="${B##+( )}"
//echo "|${C}|"
//D="${C%%+( )}"
//echo "|${D}|"


//http://www.thegeekstuff.com/2010/07/bash-string-manipulation/
// ?(pattern-list) Matches zero or one occurrence of the given patterns
// *(pattern-list) Matches zero or more occurrences of the given patterns
// +(pattern-list) Matches one or more occurrences of the given patterns
// @(pattern-list) Matches one of the given patterns
// !(pattern-list) Matches anything except one of the given patterns
//Following syntax deletes the shortest match of $substring from front of $string
//Following syntax replaces with the replacement string, only when the pattern matches beginning of the $string.
//${string/%pattern/replacement}
//${string#substring}
//Following syntax deletes the longest match of $substring from front of $string
//${string##substring}
//Following syntax deletes the shortest match of $substring from back of $string (TEST?)
//${string%substring}
//Following syntax deletes the longest match of $substring from back of $string
//${string%%substring}
// The word is expanded to produce a pattern just as in pathname expansion. If the pattern matches a trailing portion of the expanded value of parameter, then the result of the expansion is the expanded value of parameter with the shortest matching pattern (the ``%'' case) or the longest matching pattern (the ``%%'' case) deleted. If parameter is @ or *, the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable subscripted with @ or *, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.



Replace leading zeroes
TODAY=$(date +%j)
TODAY=${TODAY##+(0)}

Remember: # to the left, % to the right on a (US) keyboard. Or 'hash' is before 'per cent' in the alphabet.






=== Quoting Hell

Quoting - as I'm sure you've seen - can get very complicated in bash very
quickly.

Try this:

----
$ echo 'I really want to echo $HOME and I can't avoid it'
----

Uh-oh. You're now stuck.

Can you see why?

Hit CTRL-c to get out of it.

So you might think to try this:

----
$ echo "I really want to echo $HOME and I can't avoid it"
----

but this time the $HOME variable is evaluated and the output is not what is
wanted.

Try this:

----
$ echo 'I really want to echo $HOME and I can'"'"'t avoid it'
----

That works. Remember this trick as it can save you a lot of time!



=== Cleanup

----
$ cd ..
$ rm -rf lbthw_strings
----

=== What You Learned

TODO

- How to avoid common quoting problems.


=== Exercises

1) Learn how to do all of the above things in sed too. This will take some research and time.

2) Learn how to do all of the above in perl. This will also take some research and time!

3) Construct a useful echo that has a double-quoted string with a single-quoted string inside, eg one that outputs:

He said 'I thought she'd said "bash was easy when $$$$s are involved" but that can't be true!'


// From regexps file
//eg - BASH_REMATCH
//
//read line <&0
//regexp='([^ ]*) ([A-Z0-9_]*) (.*)'
//if [[ $line =~ $regexp ]]
//then
//    FILENAME_STRING=${BASH_REMATCH[1]}
//    TEMPLATE_STRING=${BASH_REMATCH[2]}
//    REPLACE_STRING=${BASH_REMATCH[3]}
//    sed -i "s/$TEMPLATE_STRING/$REPLACE_STRING/g" $FILENAME_STRING
//else
//    echo $0: not matched: $line
//fi
