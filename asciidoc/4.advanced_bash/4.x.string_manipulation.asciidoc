== String Manipulation

Since so much of working in bash is related to files and strings of text, the ability to manipulate strings is valuable.

While tools such as sed, awk, perl (and many many others) are well worth learning, in this section I want to show you what is possible in bash - and it may be more than you think!


=== String Length

TODO

----
$ a='1234567890'
$ echo ${#a}
$ echo $#a
----


ATTEMPTS:  TODO
b="	                 asd asd 	 "
echo ${b}
echo "|${b}|"
echo "|${b/*( )/}|"
echo "|${b//*( )//}|"




Bash provides a way to extract a substring from a string. The following example expains how to parse n characters starting from a particular position.

${string:position}


Replace only first match
${string/pattern/replacement}

Replace all the matches
${string//pattern/replacement}

Trim?
Replace beginning and end
${string/#pattern/replacement}


=== Extglobs

shopt -s extglob


If the extglob shell option is enabled using the shopt builtin, several extended pattern matching operators are recognized.  In the following description, a pattern-list is  a list of one or more patterns separated by a |.  Composite patterns may be formed using one or more of the following sub-patterns:

              ?(pattern-list) Matches zero or one occurrence of the given patterns
              *(pattern-list) Matches zero or more occurrences of the given patterns
              +(pattern-list) Matches one or more occurrences of the given patterns
              @(pattern-list) Matches one of the given patterns
              !(pattern-list) Matches anything except one of the given patterns

http://www.thegeekstuff.com/2010/07/bash-string-manipulation/

Replace leading zeroes
TODAY=$(date +%j)                                                                                                                                                                                          
TODAY=${TODAY##+(0)}



Replace leading spaces



${string:position:length}

=== Removing text
Following syntax deletes the shortest match of $substring from front of $string
${string#substring}
Following syntax deletes the longest match of $substring from front of $string
${string##substring}
Following syntax deletes the shortest match of $substring from back of $string (TEST?)
${string%substring}
Following syntax deletes the longest match of $substring from back of $string
${string%%substring}


Following syntax replaces with the replacement string, only when the pattern matches beginning of the $string.
${string/%pattern/replacement}


=== Quoting Hell

echo 'asdasd'''asdasd' ?


=== What You Learned



=== Exercises

1) Learn how to do all of the above things in sed too. This will take some research and time.

2) Learn how to do all of the above in perl. This will also take some research and time!

3) TODO
