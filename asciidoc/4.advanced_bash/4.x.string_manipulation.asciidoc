== String Manipulation

Since so much of working in bash is related to files and strings of text, the ability to manipulate strings is valuable.

While tools such as sed, awk, perl (and many many others) are well worth learning, in this section I want to show you what is possible in bash - and it may be more than you think!


=== String Length

TODO

----
$ a='1234567890'
$ echo ${#a}
$ echo $#a
----


Bash provides a way to extract a substring from a string. The following example expains how to parse n characters starting from a particular position.

${string:position}


Replace only first match
${string/pattern/replacement}

Replace all the matches
${string//pattern/replacement}

Trim?
Replace beginning and end
${string/#pattern/replacement}


=== Extglobs
http://www.linuxjournal.com/content/bash-extended-globbing

----
#!/bin/bash
shopt -s extglob
b=" 	 asd asd "
echo ${b}
echo "|${b}|"

# Single character (space)
echo "|${b/+( )/}|"
echo "|${b//+( )/}|"
          
# Multiple characters (space and tab)
echo "|${b/+([ 	])/}|"
echo "|${b//+([ 	])/}|"

# Character class
echo "|${b/+([[:space:]])/}|"
echo "|${b//+([[:space:]])/}|"

# Beginning
echo "|${b/#+([[:space:]])/}|"
# End
echo "|${b/%+([[:space:]])/}|"
----



//${!name[@]}
//${!name[*]}
// If name is an array variable, expands to the list of array indices (keys) assigned in name. If name is not an array, expands to 0 if name is set and null otherwise. When @ is used and the expansion appears within double quotes, each key expands to a separate word.
//
//${#parameter}
// The length in characters of the value of parameter is substituted. If parameter is * or @, the value substituted is the number of positional parameters. If parameter is an array name subscripted by * or @, the value substituted is the number of elements in the array.
//
//${parameter#word}
//${parameter##word}
// The word is expanded to produce a pattern just as in pathname expansion. If the pattern matches the beginning of the value of parameter, then the result of the expan- sion is the expanded value of parameter with the shortest matching pattern (the ``#'' case) or the longest matching pattern (the ``##'' case) deleted. If parameter is @ or *, the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable sub- scripted with @ or *, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.
//
//${parameter%word}
//${parameter%%word}
// The word is expanded to produce a pattern just as in pathname expansion. If the pattern matches a trailing portion of the expanded value of parameter, then the result of the expansion is the expanded value of parameter with the shortest matching pattern (the ``%'' case) or the longest matching pattern (the ``%%'' case) deleted. If parameter is @ or *, the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable subscripted with @ or *, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.
//
//${parameter/pattern/string}
// The pattern is expanded to produce a pattern just as in pathname expansion. Parameter is expanded and the longest match of pattern against its value is replaced with string. If Ipattern begins with /, all matches of pattern are replaced with string. Normally only the first match is replaced. If pattern begins with #, it must match at the beginning of the expanded value of parameter. If pattern begins with %, it must match at the end of the expanded value of parameter. If string is null, matches of pattern are deleted and the / following pattern may be omitted. If parameter is @ or *, the substitution operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable subscripted with @ or *, the substitution operation is applied to each member of the array in turn, and the expansion is the resultant list.







If the extglob shell option is enabled using the shopt builtin, several extended pattern matching operators are recognized. In the following description, a pattern-list is a list of one or more patterns separated by a |. Composite patterns may be formed using one or more of the following sub-patterns:

 ?(pattern-list) Matches zero or one occurrence of the given patterns
 *(pattern-list) Matches zero or more occurrences of the given patterns
 +(pattern-list) Matches one or more occurrences of the given patterns
 @(pattern-list) Matches one of the given patterns
 !(pattern-list) Matches anything except one of the given patterns

http://www.thegeekstuff.com/2010/07/bash-string-manipulation/

Replace leading zeroes
TODAY=$(date +%j)            
TODAY=${TODAY##+(0)}



Replace leading spaces



${string:position:length}

=== Removing text
Following syntax deletes the shortest match of $substring from front of $string
${string#substring}
Following syntax deletes the longest match of $substring from front of $string
${string##substring}
Following syntax deletes the shortest match of $substring from back of $string (TEST?)
${string%substring}
Following syntax deletes the longest match of $substring from back of $string
${string%%substring}


Following syntax replaces with the replacement string, only when the pattern matches beginning of the $string.
${string/%pattern/replacement}


=== Quoting Hell

echo 'asdasd'''asdasd' ?


=== What You Learned



=== Exercises

1) Learn how to do all of the above things in sed too. This will take some research and time.

2) Learn how to do all of the above in perl. This will also take some research and time!

3) TODO
