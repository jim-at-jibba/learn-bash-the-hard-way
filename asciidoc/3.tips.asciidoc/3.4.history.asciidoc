== History

We all know understanding history is important, and this is true in bash as well.

This section gives you a pragmatic overview of bash's history features, which can save you lots of time when at the terminal.


=== Bash and History

Bash keeps a history of commands you have run in a file. By default this is in your $HOME directory and has the name '.bash_history'.

Have a look at it:

----
TODO$ cat ~/.bash_history
----

=== Using Your History

It can be tedious to type out commands and arguments again and again, so bash offers several ways to save your effort.

Type this out and try and figure out what is going on:

----
TODO$ mkdir lbthw_history
TODO$ cd !$
TODO$ echo 'About bash history' > file1
TODO$ echo 'Another file' > file2
TODO$ grep About file1
TODO$ !!
TODO$ grep About file2
TODO$ grep Another !$
TODO$ rm file2
TODO$ !e
TODO$ !gr
----

That introduced a few tricks you haven't necessarily seen before.

All of them start with the '!' (or so-called 'bang') sign, which is the sign used to indicate that the bash history is being referred to.

The simplest, and most frequently seen is the double bang '!!', which just means: re-run the previous command.

The one I use most often, though, is the first one you come across in the listing above: '!$', or 'bang dollar'. This one I must use dozens of times every day. It tells bash to re-use the last argument of the previous command.

Finally, a 'bang' followed by 'normal' characters re-reruns the last command that matches those starting letters. The '!e' looks up the last command that ran starting with an 'e' and runs that. Similarly, the '!gr' runs the last command that started with a 'gr', ie the grep. 

Notice that the command that's rerun is the _evaluated_ command. For that grep, what is re-run is as though you typed: 'grep Another file2', and not 'grep Another !$'.

=== How to Learn Them

The history items above are enough to be going on with if you've not seen them before.

Before you go on, a quick note about learning these things: it's far more important to learn to _use_ these tricks than _understand_ them. To understand them is pretty easy - I'm sure you understood the passage above without much difficulty.

The way to learn these is to 'get them under your fingers' to the point where you don't even think about it. The way I recommend to do that is to concentrate on one of them at a time, and as you're working, remember to use that one where appropriate. Gradually you'll add more and more to your repertoire, and you will soon look like a whizz at the terminal.

==== More Advanced History Usage

You might want to stop there, as trying to memorize/learn much more in one go can be overwhelming.

But there are many more tricks to learn like this in bash, so I'm going to lay them out now so you might return to them later when you're ready.

Carrying on from where you left off above:

----
TODO$ grep Abnother file1
TODO$ ^Ab^a^
----

The caret ('^') are used to replace a string from the previous command. In this case, 'Ab' is replaced with 'a'. This is often handy if you made a spelling mistake.

Next up are the position command shortcuts, or 'word designators':

----
TODO$ grep another file1 | wc -l
TODO$ # Is that output correct? I want to check the file by eye:
TODO$ cat !:2
----

Starting with the 'bang' sign to indicate we're referring to the history, there follows a colon. Then, you specify the word with a number. The numbers are zero-based, so 


----
TODO$ grep another file1
TODO$ fgrep !:1-$
----

In the above example, you want to run the same command as before, but use the 'fgrep' command instead of 'grep' ('fgrep' is a 'faster' grep, which doesn't really help us here, but is just an example). To achieve this you use the so-called 'word designators'. 

Here you add a dash indicates you want a range of words, and the '$' sign indicates we want all the arguments up to the end of the previous command. Recall that '!$' means give me the last argument from the previous command, and so is itself a shortcut for '!:$'.

Finally, another trick I use all the time:

----
TODO$ LGTHWDIR=$(PWD)
TODO$ cd /tmp
TODO$ cat ${LGTHWDIR}/file1
TODO$ cd !$:h
----

The trick is the ':h' modifier. This is one of several modifiers available, but the only one I regularly use. When using a history shortcut, you can place a modifier at the end that starts with a colon. Here, the '!$' takes the last word from the previous command, (which you set to full directory path to the freshly-created file1 file). Then, the modifier ':h' strips off the file at the end, leaving just the directory name. I use this all the time to quickly hop into a folder of a file I just looked at.


=== History Env Vars

A quick note on environment variables that affect the history kept. TODO


----
TODO$ bash
TODO$ HISTFILE=/tmp/lbthwhist
TODO$ HISTSIZE=2
TODO$ HISTTIMEFORMAT="%d/%m/%y %T "
TODO$ ls
TODO$ pwd
TODO$ exit
TODO$ cat /tmp/lbthwhist
TODO$ rm /tmp/lbthwhist
----
bash
HISTFILE=/tmp/lbthwhist
HISTSIZE=3
HISTTIMEFORMAT="%d/%m/%y %T "
ls
exit
cat /tmp/lbthwhist

The value of 'HISTFILE' decides where the history gets saved. It defaults to the ~/.bash_history file you saw above.

By default 500 commands are saved. To change this setting, the 'HISTSIZE' 

Finally, the 'HISTTIMEFORMAT' 

HISTTIMEFORMAT If this variable is set and not null, its value is used as a format string for strftime(3) to print the time stamp  associated with  each  history  entry  displayed by the history builtin.  If this variable is set, time stamps are written to the history file so they may be preserved across shell sessions.

This is how I set up time in my bash startup files:

----
export HISTTIMEFORMAT="%d/%m/%y %T "
----

It gives me day-to-second granularity, which I usually find to be enough.


=== History Control

TODO

----
export HISTCONTROL=ignoredups:ignorespace
----

//A colon-separated list of values controlling how commands are saved on the history list.   If  the  list  of  values  includes ignorespace,  lines  which begin with a space character are not saved in the history list.  A value of ignoredups causes lines matching the previous history entry to not be saved.  A value of ignoreboth is shorthand for ignorespace  and  ignoredups.   A value of erasedups causes all previous lines matching the current line to be removed from the history list before that line is saved.  Any value not in the above list is ignored.  If HISTCONTROL is unset, or does not include a  valid  value,  all  lines read  by  the shell parser are saved on the history list, subject to the value of HISTIGNORE.  The second and subsequent lines of a multi-line compound command are not tested, and are added to the history regardless of the value of HISTCONTROL.


=== CTRL-R

Bash offers you another means to use your history.

Hit CTRL and hold it down. Then hit the 'r' key. You should see this on your terminal:

----
(reverse-i-search)`':
----

Let go. Now type 'grep'. You should see a previous grep command. If you keep hitting CTRL+r you will cycle through all commands that had grep in them, most recent first.

If you want to cycle forward (if you hit CTRL+r too many times and go past the one you want (I do this a lot)), hit CTRL+s.


==== What Next?

TODO

==== Exercises

1) Remember to use one of the above practical tips every day until you don't think about using it. Then learn another one.

2) Read up on all the history shortcuts. Pick ones you think will be useful.

3) Amend your bash startup files to control history the way you want it.

4) Think about where your time goes at the command line (eg typing out directories or filenames) and research whether there is a way to speed it up.
