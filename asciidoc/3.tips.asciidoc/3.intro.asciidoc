TRICKS / HANDY

In here are the most commonly-used techniques I use on a regular basis.

here docs

prompt

terminal codes

history, !? etc:
   Event Designators
       An event designator is a reference to a command line entry in the history list.

       !      Start a history substitution, except when followed by a blank, newline, carriage return, = or ( (when the extglob shell option
              is enabled using the shopt builtin).
       !n     Refer to command line n.
       !-n    Refer to the current command line minus n.
       !!     Refer to the previous command.  This is a synonym for `!-1'.
       !string
              Refer to the most recent command starting with string.
       !?string[?]
              Refer to the most recent command containing string.  The trailing ? may be omitted if string is followed immediately by a new-
              line.
       ^string1^string2^
              Quick substitution.  Repeat the last command, replacing string1 with string2.  Equivalent  to  ``!!:s/string1/string2/''  (see
              Modifiers below).
       !#     The entire command line typed so far.



Get a date on the script:
-------------------------

----
[metcalfs@gueabetapp37 ~]$
function dateit {
   while read line
   do
     printf "$line"
     date '+ %m-%d-%Y %H:%M:%S'
   done
}
[metcalfs@gueabetapp37 ~]$ vmstat 1 | dateit
----


Directory of script
-------------------

----
$(dirname ${BASH_SOURCE[0]})
----

http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in

    DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"


Is a useful one-liner which will give you the full directory name of the script no matter where it is being called from

These will work as long as the last component of the path used to find the script is not a symlink (directory links are OK). If you want to also resolve any links to the script itself, you need a multi-line solution:

    SOURCE="${BASH_SOURCE[0]}"
    while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
      DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
      SOURCE="$(readlink "$SOURCE")"
      [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    done
    DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
